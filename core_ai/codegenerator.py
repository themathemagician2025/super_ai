# -----------------------------------------------------------
# Author  : Clive Dziwomore (aka The Mathemagician)
# Twitter : @CDziwomore
# LinkedIn: https://www.linkedin.com/in/clive-dziwomore-194467206/
# Phone   : +91 6309784662 / +263 712967390
# -----------------------------------------------------------

# src/codegenerator.py
import pickle
import os
import logging
import random
import numpy as np
import pandas as pd
from deap import gp
import operator
from typing import Optional, Union, List, Dict, Callable
from datetime import datetime
import json
from config import pset


# Project directory structure
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
SRC_DIR = os.path.join(BASE_DIR, 'src')
LOG_DIR = os.path.join(BASE_DIR, 'log')
DATA_DIR = os.path.join(BASE_DIR, 'data')
RAW_DIR = os.path.join(DATA_DIR, 'raw')
MODELS_DIR = os.path.join(DATA_DIR, 'models')

# Ensure directories exist
for directory in [SRC_DIR, LOG_DIR, RAW_DIR, MODELS_DIR]:
    os.makedirs(directory, exist_ok=True)

# Configure logging
logging.basicConfig(
    filename=os.path.join(LOG_DIR, 'mathemagician.log'),
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Enhanced primitive set for richer expressions


def create_pset() -> gp.PrimitiveSetTyped:
    """Create a strongly-typed primitive set for GP."""
    pset = gp.PrimitiveSetTyped("MAIN", [float], float)
    pset.addPrimitive(operator.add, [float, float], float, name="add")
    pset.addPrimitive(operator.sub, [float, float], float, name="sub")
    pset.addPrimitive(operator.mul, [float, float], float, name="mul")
    pset.addPrimitive(operator.truediv, [float, float], float, name="div")
    pset.addPrimitive(np.sin, [float], float, name="sin")
    pset.addPrimitive(np.cos, [float], float, name="cos")
    pset.addPrimitive(np.exp, [float], float, name="exp")
    pset.addPrimitive(lambda x: x ** 2, [float], float, name="square")
    pset.addPrimitive(
        lambda x: np.log(
            abs(x) + 1e-10),
        [float],
        float,
        name="log")
    pset.addTerminal(0.0, float)
    pset.addTerminal(1.0, float)
    pset.addTerminal(2.0, float)
    pset.addTerminal(np.pi, float, name="pi")
    pset.renameArguments(ARG0='x')
    return pset


def generate_function_code(
        individual: gp.PrimitiveTree,
        func_name: str = "generated_func",
        include_docstring: bool = True,
        include_version: bool = True) -> str:
    """
    Generate Python code for a mathematical expression from a DEAP individual.

    Args:
        individual: A DEAP individual (PrimitiveTree) representing a mathematical expression.
        func_name: The name of the generated Python function.
        include_docstring: Whether to include a detailed docstring.
        include_version: Whether to include a version comment with timestamp.

    Returns:
        str: A string containing the Python code for the function.
    """
    expr = str(individual)
    code = ""

    # Header with imports and version
    if include_version:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        code += f"# Generated by Mathemagician CodeGenerator on {timestamp}\n"
    code += "import numpy as np\n\n"

    # Function definition
    code += f"def {func_name}(x):\n"

    # Docstring
    if include_docstring:
        code += "    \"\"\"Generated function from a DEAP individual.\n\n"
        code += f"    Args:\n        x (float): Input value.\n\n"
        code += f"    Returns:\n        float: Computed result of the expression '{expr}'.\n\n"
        code += "    Note:\n        Requires numpy for advanced mathematical operations.\n    \"\"\"\n"

    # Function body with safety
    code += "    try:\n"
    code += f"        return {expr}\n"
    code += "    except (ZeroDivisionError, OverflowError, ValueError) as e:\n"
    code += "        return float('nan')  # Return NaN for invalid operations\n"

    logger.info(
        f"Generated code for function '{func_name}' with expression '{expr}'")
    return code


def save_code_to_file(
        code: str,
        filename: str,
        directory: str = SRC_DIR) -> bool:
    """
    Save the generated code to a file in the specified directory.

    Args:
        code: The code string to save.
        filename: The destination filename (e.g., 'generated_function.py').
        directory: The directory to save to (defaults to src).

    Returns:
        bool: True if successful, False otherwise.
    """
    filepath = os.path.join(directory, filename)
    try:
        with open(filepath, 'w') as f:
            f.write(code)
        logger.info(f"Code successfully saved to {filepath}")
        return True
    except Exception as e:
        logger.error(f"Error saving code to {filepath}: {e}")
        return False


def load_code_from_file(filename: str, directory: str = SRC_DIR) -> str:
    """
    Load code from a specified file.

    Args:
        filename: The name of the file to load from (e.g., 'generated_function.py').
        directory: The directory to load from (defaults to src).

    Returns:
        str: The loaded code, or empty string if failed.
    """
    filepath = os.path.join(directory, filename)
    try:
        with open(filepath, 'r') as f:
            code = f.read()
        logger.info(f"Code successfully loaded from {filepath}")
        return code
    except Exception as e:
        logger.error(f"Error loading code from {filepath}: {e}")
        return ""


def save_individual(
        individual: gp.PrimitiveTree,
        filename: str,
        directory: str = MODELS_DIR) -> bool:
    """
    Save a DEAP individual to a file using pickle.

    Args:
        individual: The DEAP individual to save.
        filename: The destination filename (e.g., 'individual.pkl').
        directory: The directory to save to (defaults to data/models).

    Returns:
        bool: True if successful, False otherwise.
    """
    filepath = os.path.join(directory, filename)
    try:
        with open(filepath, 'wb') as f:
            pickle.dump(individual, f)
        logger.info(f"Individual successfully saved to {filepath}")
        return True
    except Exception as e:
        logger.error(f"Error saving individual to {filepath}: {e}")
        return False


def load_individual(filename: str,
                    directory: str = MODELS_DIR) -> Optional[gp.PrimitiveTree]:
    """
    Load a DEAP individual from a file using pickle.

    Args:
        filename: The name of the file to load from (e.g., 'individual.pkl').
        directory: The directory to load from (defaults to data/models).

    Returns:
        gp.PrimitiveTree: The loaded individual, or None if failed.
    """
    filepath = os.path.join(directory, filename)
    try:
        with open(filepath, 'rb') as f:
            individual = pickle.load(f)
        logger.info(f"Individual successfully loaded from {filepath}")
        return individual
    except Exception as e:
        logger.error(f"Error loading individual from {filepath}: {e}")
        return None


def load_raw_data() -> Dict[str, pd.DataFrame]:
    """Load CSVs from data/raw for validation."""
    raw_data = {}
    for filename in os.listdir(RAW_DIR):
        if filename.endswith('.csv'):
            filepath = os.path.join(RAW_DIR, filename)
            try:
                df = pd.read_csv(filepath)
                if 'x' in df.columns and 'y' in df.columns:
                    raw_data[filename] = df
                    logger.info(f"Loaded raw data: {filepath}")
            except Exception as e:
                logger.error(f"Failed to load {filepath}: {e}")
    return raw_data


def validate_generated_function(
        individual: gp.PrimitiveTree,
        pset: gp.PrimitiveSetTyped) -> float:
    """
    Validate the generated function against raw data using MSE.

    Args:
        individual: The DEAP individual to validate.
        pset: The primitive set used to compile the individual.

    Returns:
        float: Mean squared error (lower is better), or infinity if invalid.
    """
    raw_data = load_raw_data()
    if not raw_data:
        logger.warning("No raw data available for validation.")
        return float('inf')

    try:
        func = gp.compile(individual, pset)
        total_mse = 0
        count = 0
        for df in raw_data.values():
            y_pred = [func(x) for x in df['x'].values]
            mse = np.mean((df['y'].values - y_pred) ** 2)
            total_mse += mse
            count += 1
        mse = total_mse / count if count > 0 else float('inf')
        logger.info(f"Validated individual with MSE: {mse}")
        return mse
    except Exception as e:
        logger.error(f"Validation error: {e}")
        return float('inf')


def mutate_expression(individual: gp.PrimitiveTree,
                      pset: gp.PrimitiveSetTyped) -> gp.PrimitiveTree:
    """
    Mutate the individual with a dangerous autonomous twist (book theme).

    Args:
        individual: The DEAP individual to mutate.
        pset: The primitive set for mutation.

    Returns:
        gp.PrimitiveTree: The mutated individual.
    """
    if random.random() < 0.05:  # 5% chance of aggressive mutation
        expr = str(individual) + " * square(x)"
        try:
            new_individual = gp.PrimitiveTree.from_string(expr, pset)
            logger.warning(f"Dangerous autonomous mutation applied: {expr}")
            return new_individual
        except Exception as e:
            logger.error(f"Autonomous mutation failed: {e}")

    # Standard mutation
    slice_ = individual.searchSubtree(random.randint(0, len(individual) - 1))
    expr = gp.genGrow(pset, min_=1, max_=3, type_=float)
    individual[slice_] = gp.PrimitiveTree(expr)
    return individual


def generate_and_save(
        individual: gp.PrimitiveTree,
        pset: gp.PrimitiveSetTyped,
        func_name: str = "generated_func",
        filename: str = "generated_function.py") -> bool:
    """
    Generate and save a function with validation and optional mutation.

    Args:
        individual: The DEAP individual to generate code from.
        pset: The primitive set for compilation and mutation.
        func_name: Name of the generated function.
        filename: Filename for the saved code.

    Returns:
        bool: True if successful, False otherwise.
    """
    mse = validate_generated_function(individual, pset)
    if mse > 1000:  # Arbitrary threshold for mutation trigger
        individual = mutate_expression(individual, pset)
        logger.info("Individual mutated due to high MSE")

    code = generate_function_code(individual, func_name)
    return save_code_to_file(code, filename)


def batch_generate(population: List[gp.PrimitiveTree],
                   pset: gp.PrimitiveSetTyped,
                   prefix: str = "func") -> List[str]:
    """Generate code for a population of individuals."""
    filenames = []
    for i, ind in enumerate(population):
        func_name = f"{prefix}_{i}"
        filename = f"{func_name}.py"
        if generate_and_save(ind, pset, func_name, filename):
            filenames.append(filename)
    return filenames


def main():
    """Demonstrate code generation with enhanced functionality."""
    random.seed(42)
    pset = create_pset()

    # Generate a population of individuals
    population = []
    for _ in range(5):
        expr = gp.genHalfAndHalf(pset, min_=1, max_=4, type_=float)
        population.append(gp.PrimitiveTree(expr))

    # Save individuals
    for i, ind in enumerate(population):
        save_individual(ind, f"individual_{i}.pkl")

    # Load and validate one individual
    loaded_ind = load_individual("individual_0.pkl")
    if loaded_ind:
        mse = validate_generated_function(loaded_ind, pset)
        print(f"Loaded individual MSE: {mse}")

        # Generate and save code
        code = generate_function_code(loaded_ind, "dummy_function")
        save_code_to_file(code, "dummy_function.py")

        # Load and display
        loaded_code = load_code_from_file("dummy_function.py")
        print("Generated Code:\n", loaded_code)

    # Batch generate for population
    filenames = batch_generate(population, pset, "math_func")
    print(f"Generated files: {filenames}")


if __name__ == "__main__":
    main()

# Additional utilities


def test_generated_function(filename: str,
                            test_values: List[float]) -> List[float]:
    """Test a generated function with provided values."""
    code = load_code_from_file(filename)
    if not code:
        return []

    namespace = {}
    try:
        exec(code, namespace)
        func = namespace[filename.split('.')[0]]
        results = [func(x) for x in test_values]
        logger.info(f"Tested {filename} with values {test_values[:5]}...")
        return results
    except Exception as e:
        logger.error(f"Error testing {filename}: {e}")
        return []


def optimize_individual(
        individual: gp.PrimitiveTree,
        pset: gp.PrimitiveSetTyped,
        iterations: int = 10) -> gp.PrimitiveTree:
    """Optimize an individual by iteratively mutating and validating."""
    best_ind = individual
    best_mse = validate_generated_function(best_ind, pset)
    for _ in range(iterations):
        mutated = mutate_expression(best_ind.copy(), pset)
        mse = validate_generated_function(mutated, pset)
        if mse < best_mse:
            best_ind = mutated
            best_mse = mse
            logger.info(f"Improved individual MSE: {mse}")
    return best_ind


def generate_with_metadata(
        individual: gp.PrimitiveTree,
        func_name: str) -> str:
    """Generate code with metadata (e.g., fitness, generation date)."""
    mse = validate_generated_function(individual, pset)
    code = generate_function_code(individual, func_name)
    code = f"# Fitness (MSE): {mse}\n" + code
    return code
